1. ajax，fetch和axios的区别
    1. ajax 是一种技术统称，用于完成客户端和服务端异步通信，实现局部刷新页面的效果
    2. fetch
        1. 浏览器原生API，用于网络请求
        2. 和XMLHttpRequest是一个级别的
        3. 更加简洁好用，支持promise
        4. 服务器返回 400，500 等错误码时并不会 reject。仅当网络故障时或请求被阻止时，才会标记为 reject
    3. axios
        1. 是一个第三方库
        2. 支持node和浏览器（从浏览器中创建 XMLHttpRequest，从 node.js 创建 http 请求）
        3. 支持 Promise API
        4. 可以拦截和响应请求
        5. 自动转换JSON数据
        6. 可以取消请求(CancelToken 已经被弃用了)

```
<!-- axios取消请求 -->
const controller = new AbortController();

axios.get('/foo/bar', {
   signal: controller.signal
}).then(function(response) {
   //...
});
// 取消请求
controller.abort()
```

2. 节流和防抖

```
<!-- 防抖 -->
防抖：n秒钟内执行事件，如果在n秒内重复触发，则重新计时
场景：搜索框搜索输入。只需要用户最后一次输入完，再发送请求；窗口resize事件，只有窗口调整完后，才计算窗口大小。防止重复渲染
function debounce(fn,delay=300) {
   let timer = null
   return function(...args) {
    const ctx = this
    clearTimeout(timer)
    timer = setTimeout(() => {
        fn.apply(ctx, args)
    }, delay)
   }
}

<!-- 节流 -->
节流：在n秒内只执行一次，如果多次触发也是只执行一次
场景：滚动加载，加载更多或滚动到底部监听；搜索框，搜索联想
//使用时间戳写法，事件会立即执行，停止触发后没有办法再次执行
function throttled1(fn,delay=300) {
    let start =  Date.now()
    return function(...args) {
        const end = Date.now()
        const ctx = this
        if (delay <= (end - start)) {
            fn.apply(ctx, args)
            start = Date.now()
        }
    }
}

//delay毫秒后第一次执行，第二次事件停止触发后依然会再一次执行
function throttled2(fn,delay=300) {
    let timer = null
    return  function(...args) {
        const ctx = this
        if(!timer) {
			timer = setTimeout(()=>{
				fn.apply(this, args)
				timer = null
			},delay)
		}
    }
}
```

3. px % rpx em rem vw/vh的区别
    1. px：绝对单位值，一个像素
    2. rpx：微信小程序解决自适应屏幕尺寸的尺寸单位，可以根据屏幕宽度进行自适应
    3. em：在font-size中是相对于父元素的字体大小，在其他属性中是相对于自身的字体大小，如width
    4. rem: 是相对于根元素html，只需要设置根元素大小，即可将整个页面的比例设置好。浏览器默认字体大小，一般是16px
    5. %： 相对于父元素大小的百分比值
    6. vh和vw：相对于可视窗口的高度和宽度，1vh等于1/100的视口高度，1vw等于1/100的视口宽度。比如：浏览器高度900px，宽度为750px,1vh=900px/100=9px,1vw = 750px/100=7.5px
    7. vmin和vmax：vmin是vh和vw中的较小值，vmax是vh和vw中的较大值

4. 箭头函数有什么缺点？什么时候不能使用箭头函数？
    1. 箭头函数的缺点
        1. 没有arguments
        2. 无法通过apply,call和bind改变this指向
        3. 某些嵌套箭头函数代码难以阅读
    2. 不能使用箭头函数的场景
        1. 对象方法中。当要通过this来获取对象自身的属性或方法时，不能使用箭头函数
        2. 对象的原型方法中。
        3. 构造函数
        4. 动态上下文的回调函数中。如监听事件，想要获取this的对象，就不能使用箭头函数
        5. vue2中的生命周期函数和method方法。vue的组件本质上是一个对象。（补充：React组件本质上是class，这里面可以使用箭头函数，是可以获取自身的属性和方法的）

5. 请描述TCP三次握手和四次挥手（网络连接TCP协议，传输内容是HTTP协议）
    1. 三次握手
        1. client发包，server接收。server知道有client要找它
        2. server发包，client接收。client知道server已经接收到消息了
        3. client发包，server接收。server知道client要准备发送请求了
    2. 四次挥手
        1. client发包，server接收。server知道client已经发完请求了
        2. server发包，client接收。client知道server已经收到消息，等待server关闭。此时，server可能还在返回数据，还没停止
        3. server发包，client接收。client知道server已经发送完数据了，此时可以关闭连接了
        4. client发包，server接收。server关闭连接

6. for-in和for-of的区别
    1. for-in 用于遍历可枚举数据，即Object.getOwnProperDescritors()。 如对象，数组，字符串
    2. for-of 用于遍历可迭代数据，即有Symbol.iterator属性的。 如对象，数组，字符串，Map，Set
    3. 注意
        1. 遍历对象：for-in可以，for-of不可以
        2. 遍历Map，Set：for-of可以，for-in不可以
        3. 遍历generator：for-of可以，for-in不可以
        4. for-in会遍历原型链上的可枚举属性
        5. for-of可以与break、continue和return配合使用
    4. （连环问题）for-await-of的作用：用于遍历多个Promise。类似于Promise.all

    ```
            function createPromise(val) {
            return new Promise((resolve) => {
                setTimeout(() => {
                    resolve(val)
                }, 2000);
            })
        }
        !(async function() {
            // const p1 = createPromise(10)
            // const p2 = createPromise(20)
            // const p3 = createPromise(30)

            // 同时出现
            // const r1 = await p1
            // console.log(r1)
            // const r2 = await p2
            // console.log(r2)
            // const r3 = await p3
            // console.log(r3)

            // 同时出现
            // const list = [p1,p2,p3]
            // Promise.all(list).then(res => console.log(res))

             // 同时出现
            // const list = [p1,p2,p3]
            // for await (let res of list) {
            //     console.log(res)
            // }

            //---------分割------------

            // 实现依次出现，而不是同时出现
            // const p1 = await createPromise(10)
            // console.log(p1)
            // const p2 = await createPromise(20)
            // console.log(p2)
            // const p3 = await createPromise(30)
            // console.log(p3)

            // 实现依次出现，而不是同时出现
            const list = [10,20,30]
            for (let num of list) {
                const res = await createPromise(num)
                console.log(res)
            }
        })()
    ```
7. offsetHeight，scrollHeight和clientHeight的区别
    1. offsetHeight/offsetWidth: border + padding + content
    2. clientHeight/clientWidth: padding + content
    3. scrollHeight/scrollWidth: padding + 实际内容尺寸（可能会被子元素撑开）

8. HTMLConllection和NodeList区别
    1. HTMLConllection 是Element的集合
    2. NodeList是Node集合
    3. Node和Element区别
        1. DOM是一棵树，所有节点都是Node
        2. Node是Element的基类
        3. Element是其他HTML元素的基类，如HTMLDivElement
    4. 获取Node和Element的返回结果可能不一样：如ele.childNodes和ele.children不一样。前者包含Text和Comment节点，后者不会
    5. HTMLConllection和NodeList都是类数组，转成数组方式有：
        1. Array.from(list)
        2. Array.property.slice.call(list)
        3. [...list]

9. computed和watch的区别
    1. computed是计算属性，计算属性的返回值，可以直接使用；watch是监听器，监听某个值发生变化然后执行对应的回调函数
	2. computed中所依赖的属性值没有变化的时候，就不会再计算，而是直接使用之前的值。
	3. computed默认第一次加载的时候就开始监听；watch默认第一次加载不做监听
	4. computed必须有return，而watch没有
	5. 使用场景： computed可以用在当一个值受多个属性影响的时候-->购物车商品结算, watch----当一条数据影响多条数据的时候-->搜索框。

10. Vue组件的通讯方式
    1. props和$emit  父子组件传值
    2. 自定义事件 兄弟组件或不相干的组件传值，vue3中需要引入event-emitter插件
    3. $attrs 作为props和$emit的替换方案。会获取除了props外的传入的值和事件。可以通过 v-bind="$attrs" 传入内部组件
    4. $parent 可以获取父组件的方法和属性
    5. $refs 可以获取子组件的方法和属性
    6. provide和inject 可以跨多级传值。当需要传入响应值是要把provide写成方法的形式
    7. Vuex

11. vuex中action和mutation的区别
    1. mutation是原子操作，必须是同步代码
    2. action是可以包含多个mutation，也可以包含异步代码

12. js中严格模式下有什么特点 'use strict'
    1. 全局变量必须先声明再使用
    2. 禁止使用with
    3. 不使用eval创建作用域
    4. 禁止this指向window
    5. 函数参数不能重名

13. HTTP跨域请求时为何发送options请求
    1. options请求是跨域请求之前的预检查，可以知道服务端支持那些方法
    2. 浏览器自动发起的，不需要我们干预
    3. 不会影响开发的实际功能

14. JS垃圾回收
    1. 什么是垃圾回收？就是函数执行完成，回收再也用不到的对象或变量
    2. 之前是用引用计数来清除，循环引用无法清除
    3. 现在是用标记清除，即从window开始逐步向下遍历，能获取到的对象或变量就不清除，找不到的就清除
    4. 连环问题：js闭包是内存泄漏吗？内存泄漏是指那些非预期的情况，即本应该被回收，但不能被回收的情况。而闭包是数据不可以被回收，是预期之内的。

15. JS内存泄漏如何检测呢？
    1. 使用chrome devTools的Performance和Memory工具来检测，使用前得先点击小垃圾箱清除垃圾。点击小黑原点，然后执行页面操作，然后点击stop即完成检测
    2. 一个合理的内存使用情况应该是一个锯齿状的，即有创建也有回收。如果没有回收，则是一个一直递增的形状。

16. 内存泄漏的场景有那些？（vue为例）
    1. 被全局变量、函数引用，组件销毁时未清除
    2. 被全局事件、定时器引用，组件销毁时未清除
    3. 被自定义事件引用，组件销毁时未清除
    4. 连环问题：WeakMap和WeakSet的垃圾回收？它们都是弱引用，即不能影响正常的垃圾回收，该回收的还是会被回收。

17. 浏览器和nodejs的事件循环有什么区别？
    1. 浏览器
        1. 同步任务 + 微任务 + DOM渲染 + 宏任务
        2. 微任务：Promise.then，async/await
        3. 宏任务：setTimeout，setInterval，网络请求，DOM事件
    2. Node
        1. 同步任务 + 微任务 + 按顺序执行6个类型的宏任务（每个开始时都会先执行当前的微任务）
        2. 微任务：Promise.then，async/await，process.nextTick(优先级最高，优先执行)
        3. 宏任务：
            1. Timer: setTimeout setInterval
            2. I/O callbacks 处理网络请求
            3. Idle,prepare 闲置状态（nodejs内部使用）
            4. Poll轮询 执行poll中的i/o队列
            5. Check查询 存储setImmediate回调
            6. Close callbacks 关闭回调，如socket.on('close')

18. vdom真的很快吗？
    1. vdom是指用js对象模拟DOM节点数据
    2. Vue和React等框架的核心价值
        1. 组件化
        2. 数据视图分离，数据驱动视图--->核心价值点
        3. 只关注业务数据，不用再关心DOM变化
    3. 总结
        1. vdom并不快，直接用js操作DOM才是最快的
        2. 但是“数据驱动视图”必须要有合适的技术方案，不能全部DOM重建
        3. vdom就是目前来说最合适的技术方案，不是因为它很快，而是合适

19. 遍历一个数组，for和forEach那个更快?
    1. for更快
    2. forEach每次都要创建一个函数来调用，而for不会创建函数
    3. 函数需要独立的作用域，会有额外的开销

20. nodejs中进程和线程
    1. 进程：os进行资源分配和调度的最小单位，有独立内存空间
    2. 线程：os进行运算调度的最小单位，共享进程内存空间
    3. js是单线程的，但是可以开启多进程执行，如WebWorker

21. 为什么需要多进程？
    1. 多核CPU，更适合处理多进程
    2. 内存较大，多个进程才能更好的利用（单进程有内存上限）
    3. 压榨机器资源，更快更节省

22. nodejs开启进程的方式
    1. child_process：主要用于开启单个进程进行计算

    ```
    const fork = require('child_process').fork

    // 开启子进程
    const computeProcess = fork(js文件地址)
    computeProcess.send('xxx') // 传递消息给子进程
    computeProcess.on('message', data => {
        console.log(data)
    }) //接收子进程返回的数据
    computeProcess.on('close', () => {
        console.log('子进程意外关闭')
    }) //处理当子进程意外关闭的情况

    <!--  子进程-js文件地址 -->
    process.on('message', data => {
        console.log(process.pid) //进程id
        console.log(data) //从主线程传递的消息
        const sum = 'xxx'
        process.send(sum) //传递消息给主线程
    })
    ```

    2. cluster：主要用于开启多个服务多个进程

    ```
    const http = require('http')
    const cpuCoreLength = require('os').cpus().length
    const cluster = require('cluster')

    if(cluster.isMaster) {
        for(let i = 0;i < cpuCoreLength; i++) {
            cluster.fork()
        }
        cluster.on('exit', worker => {
            console.log('子进程退出')
            cluster.fork() //进程守护
        })
    } else {
        // 多个子进程会共享一个tcp连接，提供一份网络服务
        const server = http.createServer((req,res) => {
            res.writeHead(200)
            res.end('done')
        })
        server.listen(3000)
    }
    ```

23. 什么是JS Bridge
    1. APP内的网页中的js无法直接调用API，只能通过APP自己封装一些特定API到网页中，然后网页中的JS调用这些特定API执行某些功能
    2. js无法直接调用native API
    3. 需要通过一些封装后的特定格式来调用
    4. 这些特定格式就是JS Bridge，比如微笑JSSDK
    5. JS Bridge目前有两种方式
        1. 注册全局API: 只能处理一些简单的同步的情况
        2. URL Scheme: 可以处理比较复杂的情况

24. requestIdleCallback和requestAnimationFrame的区别
    1. requestAnimationFrame是每次渲染完都会执行，高优
    2. requestIdleCallback是空闲时才会执行，低优
    3. 连环问题：它们是宏任务还是微任务？ 都是宏任务。都要等到DOM渲染后才执行。

25. Vue的生命周期
    1. beforeCreate：创建一个空白的Vue实例。data和method尚未被初始化，不可使用
    2. created：初始化完成，完成响应式绑定。data和method已经初始化完成，可以调用。尚未开始渲染模板。$el还不可用
    3. beforeMount：编译模板，调用render生成vdom，此时还没开始渲染DOM
    4. mounted：完成DOM渲染，组件创建完成。开始由“创建阶段”进入“运行阶段”
    5. beforeUpdate：data发生变化之后，准备更新DOM（尚未更新DOM）
    6. Updated：data发生变化，且DOM更新完成。（不要在updated中修改data，可能会导致死循环）
    7. beforeUnmount：组件进行销毁（尚未销毁，可正常使用）。可移除、解绑一些全局事件和自定义事件
    8. unmounted：组件被销毁了，所有指令、事件侦听器都被移除。所有子组件实例都被卸载。
    9. activated：被keep-alive缓存的组件激活时调用
    10. deactivated: 被keep-alive缓存的组件失活时调用
    11. 连环问题：什么时候操作DOM比较合适？mounted和updated都不能保证子组件全部加载完成，可以使用$nextTick渲染DOM
    12. 连环问题：Vue3有什么区别？使用setup替代了beforeCreate和Created。使用hooks函数形式。

26. vue2、vue3以及React的diff算法不同点
    1. vue2 - 双端比较：用四个指针来同时比较，然后指针移动再比较
    2. vue3 - 最长递增子序列
    3. React - 仅右移
    4. Tree diff的优化
        1. 只比较同一层，不跨级比较
        2. tag不同层则删掉重建（不再去比较内部的细节）
        3. 子节点通过key区分
    5. 连环问题： Vue和React为何循环时必须要用key?
        1. vdom diff算法会根据key判断元素是否要删除
        2. 匹配了key，则只需要移动元素 -- 性能较好
        3. 未匹配key，则需要删掉重建 -- 性能较差

27. Vue-router的三种模式
    1. Hash
    2. WebHistory
    3. MemoryHistory

28. Retina 屏 1px 像素问题，如何实现
    1. 有些手机屏幕的 DPR = 2 ，即 1px 它会用两个物理像素来显示，就粗了
    2. 使用 css 伪类 + transform 来优化这一问题。即把默认的 1px 宽度给压缩 0.5 倍

    ```
    #box {
    padding: 10px 0;
    position: relative;
    }
    #box::before {
        content: '';
        position: absolute;
        left: 0;
        bottom: 0;
        width: 100%;
        height: 1px;
        background: #d9d9d9;
        transform: scaleY(0.5);
        transform-origin: 0 0;
    }
    ```

    3. 连环问题：如果有 border-radius 怎么办？ 设置box-shadow

    ```
    X 偏移量 0
    Y 偏移量 0
    阴影模糊半径 0
    阴影扩散半径 0.5px
    阴影颜色
    #box2 {
    margin-top: 20px;
    padding: 10px;
    border-radius: 5px;
    /* border: 1px solid #d9d9d9; */
    box-shadow: 0 0 0 0.5px #d9d9d9;
    }
    ```

29. 网络请求中，token和cookie有什么区别？
    1. cookie
        1. 介绍
            1. HTTP无状态，每次请求都要带上cookie，以帮助识别身份
            2. 服务端也可以向客户端set-cookie，cookie大小限制4kb
            3. 默认有跨域限制：不可跨域共享、传递cookie（可以通过设置withCredentials来实现跨域共享和传递；或者设置domain主域名）
        2. 现代浏览器开始禁止第三方cookie
            1. 和跨域限制不同。这里是：禁止网页引入的第三方js设置cookie
            2. 打击第三方广告，保护用户隐私
            3. 新增属性SameSite:Strict/Lax/None;可自行选择值
        3. cookie和session
            1. cookie用于登录验证，存储用户标识（如userID)
            2. session在服务器端（内存中），存储用户详细信息，和cookie信息一一对应
            3. cookie+session是常见的登录验证解决方案
    2. token
        1. 介绍
            1. cookie是HTTP规范，而token是自定义传递
            2. cookie会默认被浏览器存储，而token需要自己存储
            3. token默认没有跨域限制
        2. JWT(json web token)
            1. 前端发起登录，后端验证成功之后，返回一个加密的token
            2. 前端自行存储这个token（包含了用户信息，加密了）
            3. 以后访问服务器端口，都要带着这个token，作为用户信息
    3. 连环问题：Session和JWT那个更好？
        1. Session
            1. 优点
                1. 原理简单，易于学习
                2. 用户信息存储在服务端，可快速封禁某个用户
            2. 缺点
                1. 占用服务器内存，硬件成本高
                2. 多进程，多服务器时，不好同步 --- 需要第三方缓存，如redis
                3. 默认有跨域限制
        2. JWT
            1. 优点
                1. 不占用服务器内存
                2. 多进程，多服务器不受影响
                3. 没有跨域限制
            2. 缺点
                1. 用户信息存储在客户端，无法快速封禁某个用户(可用黑名单)
                2. 万一服务器端密钥被泄漏，则用户信息全部丢失
                3. token体积一般大于cookie，会增加请求的数据量
        3. 比较
            1. 如果有严格管理用户信息的需求（保密、快速封禁）推荐Session
            2. 如果没有特殊要求，则使用JWT
    4. 如何实现sso单点登录
        1. 有A网站，B网站和第三方独立网站（专门用来验证）
        2. 第一次访问A网站，A网站会将登录重定向到第三方网站
        3. 验证信息等都交给第三方网站来验证，验证通过后会回传一个token和sso凭证。这个token值会保存在A网站下和第三方网站下
        4. 下次登录A网站时会带上token值，继续到第三方验证，通过后即可登录
        5. 当登录B网站时（不用输入账号密码），会带上第三方网站下存储的token，然后去验证，通过后又会返回一个token到B网站下
        6. 总结一点就是：都要通过第三方独立网站去验证，只要在第三方验证后都可以登录

30. HTTP协议和UDP协议的区别？
    1. HTTP协议在应用层
    2. TCP和UDP在传输层
    3. TCP协议
        1. 有连接（三次握手）
        2. 有断开（四次挥手）
        3. 稳定传输
    4. UDP协议
        1. 无连接，无断开
        2. 不稳定传输，但效率高
        3. 如视频会议，语音通话
    5. 连环问题：HTTP协议1.0，1.1和2.0有什么区别
        1. 1.0版本
            1. 最基础的HTTP协议
            2. 支持最基本的get,post协议
        2. 1.1版本
            1. 缓存策略Cache-control E-tag等
            2. 支持长连接Connection:keep-alive，一次TCP连接多次请求
            3. 断点续传，状态码206
            4. 支持新的方法PUT DELETE等，可用于Restful API
        3. 2.0版本
            1. 可压缩header，减少体积
            2. 多路复用，一次TCP连接可以多个HTTP并行请求
            3. 服务端推送

31. 什么是HTTPS中间人攻击？如何预防？
    1. HTTPS加密过程 ---> 先非对称加密后对称加密
        1. 使用非对称加密，生成公钥和私钥
        2. 将公钥传输给客户端
        3. 客户端使用公钥生成随机码，并将这个随机码加密后传输给服务端
        4. 服务端使用私钥解密随机码，获取解密后的随机码，并使用这个随机码对数据进行加密
        5. 客户端使用之前生成的随机码来解密数据
    2. 中间人攻击
        1. 劫持通信，伪造CA证书，生成公钥和私钥
        2. 利用伪造生成的公钥和私钥进行数据加密
    3. 如何预防：使用安全的，可靠的SSL证书，不要使用免费的，不知名的证书

32. JS中defer和async的区别
    1. 无：HTML暂停解析，下载JS，执行JS，再继续解析HTML
    2. defer：HTML继续解析，并行下载JS，HTML解析完后再执行JS
    3. async：HTML继续解析，并行下载JS，执行JS，再解析HTML
    4. 连环问题：prefetch和dns-prefetch有什么区别？
        1. prefetch和preload
            1. prefetch表示资源在未来页面可能会使用，空闲时加载
            2. preload表示资源在当前页面使用，要优先加载
        2. dns-prefetch和preconnet
            1. dns-prefetch即DNS预查询
            2. preconnet即DNS预连接
        3. 答案：无关，前者是资源预获取，后者是DNS预查询

33. 常见的前端攻击有那些？如何预防？
    1. XSS
        1. Cross Site Script 跨站脚本攻击
        2. 手段：将JS代码插入到网页内容中，渲染时执行JS代码
        3. 预防：特殊字符替换（前端和后端都可以）
    2. CSRF
        1. Cross Site Request Forgery 跨站请求伪造
        2. 诱导用户去访问另一个网站的接口，伪造请求
        3. 严格的跨域限制 + 验证码机制 + 为Cookie设置SameSite
    3. 点击劫持
        1. Click Jacking
        2. 诱导页面上蒙一个透明的iframe，诱导用户进行点击
        3. 让iframe不能跨域加载：设置X-Frame-Options：sameorigin
    4. DDoS
        1. 分布式拒绝服务
        2. 手段：分布式的、大规模的流量访问，使服务器瘫痪
        3. 做硬件预防（阿里云WAF）
    5. SQL注入
        1. 提交内容时写入SQL语句，破坏数据库
        2. 处理输入的内容，替换特殊字符

34. WebSocket和HTTP的区别
    1. WebSocket
        1. 支持端对端通讯
        2. 可以由client发起，也可以由server发起
        3. 用于：消息通知，直播间讨论区，聊天室，协同编辑等
        4. 实际项目推荐使用scoket.io，API更见简洁
    2. WebSocket连接过程
        1. 先发起一个HTTP请求
        2. 成功之后再升级到WebSocket协议，再通讯
    3. 二者区别
        1. WebSocket协议名是ws://，可双端发起请求
        2. WebSocket没有跨域限制
        3. 通过send和onmessage通讯（HTTP通过req和res）
    4. 连环问题：WebSocket和HTTP长轮询的区别？
        1. HTTP长轮询：客户端发起请求，服务端阻塞，不会立即返回。当返回后，客户端会再立即发送请求。再重复这个过程。
        2. WebSocket：客户端可发起请求，服务端也可以发起请求

35. 描述从输入url到页面展示的完整过程
    1. 网络请求
        1. DNS查询（得到IP），建立TCP连接（三次握手）
        2. 浏览器发起HTTP请求
        3. 收到请求响应，得到数据（HTML，css，js，媒体资源）
    2. 解析
        1. HTML构建DOM树
        2. css构建CSSOM树
        3. 两者结合，形成render Tree
    3. 渲染
        1. 计算各个DOM的尺寸，定位等，最后绘制到页面上
        2. 遇到JS会先执行JS
        3. 异步加载CSS、图片，可能会触发重新渲染
    4. 连环问题：重绘repaint和重排reflow的区别？
        1. 重绘：元素外观改变，如颜色，背景色等。但元素的尺寸和定位不会变，不会影响到其他元素的位置
        2. 重排：重新计算尺寸和布局，可能会影响到其他元素的位置。比如元素增高，可能会使得相邻元素位置下移
        3. 减少重排方案：
            1. 集中修改样式，或者直接切换css class
            2. 修改之前先设置display:none，脱离文档流。修改后再改回来
            3. 使用BFC特性，不会影响到其他元素的位置
            4. 频繁触发（resize scroll）使用节流和防抖
            5. 使用createDocumentFragment 批量操作DOM
            6. 优化动画，使用CSS3和requestAnimationFrame
    5. 拓展BFC
        1. 解释：块级格式化上下文。内部元素无论如何改动，都不会影响其他元素的位置
        2. 触发条件：
            1. 根节点`<html>`
            2. float:left/right
            3. overflow:auto/scroll/hidden
            4. display:inline-block/table/table-row/table-cell
            5. display:flex/grid;的直接子元素
            6. position:absolute/fixed