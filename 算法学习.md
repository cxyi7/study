1. 复杂度
* 程序执行时所需要的计算量和内存空间（与代码是否简洁无关）
* 复杂度是数量级，不是具体的数字
* 一般针对一个算法，而不是一个完整的系统

2. 时间复杂度（数量级）
   1. o(1) 一次
   2. o(n) 与传输的数据量一样
   3. o(n^2) 数据量的平方
   4. o(logn) 数据量的对数
   5. o(n*logn) 数据量 * 数据量的对数

3. 空间复杂度（数量级）
   1. o(1) 一个单位
   2. o(n) 与数据量一样大的单位

4. 栈和数组的区别
   1. 栈     逻辑结构。理论模型，不管如何实现，不受任何语言的限制
   2. 数组   物理结构。真实的功能实现，受限于编程语言

5. 链表和数组的区别
   1. 链表是一种物理结构(非逻辑结构),类似于数组
   2. 数组需要一段连续存储的内存区间,而链表是零散的
   3. 链表的数据结构为{value, next?, prev?}
   4. 链表: 查询慢 o(n), 新增和删除快o(1)
   5. 数组: 查询快 o(1), 新增和删除慢o(n)

6. 数据结构的选择，要比算法优化更重要

7. 要有时间复杂度的敏感性，比如length不能遍历查找

8. 凡有序，必二分！！ 凡二分，时间复杂度必包含o(logn)！！！

9. 优化嵌套循环，可以考虑使用“双指针”

10. 二叉搜索树BST：查找快，增删快

11. 平衡二叉树
    1. 如果BST不平衡，则会变成链表
    2. 所以要尽量平衡：平衡二叉搜索树BBST
    3. BBST增删查，时间复杂度都是o(logn)，即树的高度

12. 堆栈模型
    1. 值类型变量，存储在栈
    2. 引用类型变量，存储在堆

13. 堆
    1. 完全二叉树
    2. 最大堆： 父节点 >= 子节点
    3. 最小堆： 父节点 =< 子节点

13. 堆的逻辑结构是一棵二叉树，但物理结构是一个数组

14. 堆 vs BTS
    1. 堆的查询比BST慢
    2. 增删比BST快，维持平衡更快
    3. 但整体的时间复杂度都在o(logn)级别，即树的高度

15. 堆的使用场景
   1. 特别适合“堆栈模型”
   2. 堆的数据，都是在栈中引用的，不需要从root遍历
   3. 堆是数组形式，根据栈的地址，可用o(1)查找到目标

### 以下为算法题目

1. [将一个数组旋转K步](answer/rorate.js)
2. [判断一个字符串是否括号匹配](answer/matchBracket.js)
3. [用两个栈实现一个队列](answer/two-stacks-one-queue.js)
4. [用一个js函数,反转单向链表](answer/reverse-link-list.js)
5. [用链表和数组实现队列那个更快](answer/queue-with-list.js)
6. [用js实现二分查找](answer/binary-search.js)
7. [给一个数组，找出其中和为n的两个元素](answer/two-numbers-sum.js)
8. [求一个二叉树的第K小值](answer/binary-search-tree.js)